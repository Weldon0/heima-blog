---
title: 🌹 5.tcp
---



## TCP的特性

主要有以下5点特性：

1. TCP 提供⼀种⾯向连接的、可靠的字节流服务

2. 在⼀个 TCP 连接中，仅有两⽅进⾏彼此通信（⼴播和多播不能⽤于 TCP）

3. TCP 使⽤校验、确认和重传机制来保证可靠传输

4. TCP 将数据分节进⾏排序，并使⽤累积来确认保证数据的顺序不变和⾮重复

5. TCP 使⽤滑动窗⼝机制来实现流量控制，通过动态改变窗⼝的⼤⼩进⾏拥塞控制


## 简述 TCP 和 UDP 的区别

| 协议 | 连接性   | 双工性     | 可靠性                 | 有序性            | 有界性             | 拥塞控制 | 传输速度 | 量级 | 头部大小  |
| ---- | -------- | ---------- | ---------------------- | ----------------- | ------------------ | -------- | -------- | ---- | --------- |
| TCP  | ⾯向连接 | 全双工 1:1 | 可靠，有重传机制       | 有序，通过SYN排序 | 无边界，有粘包情况 | 有       | 慢       | 低   | 20~60字节 |
| UDP  | 无连接   | n:m        | 不可靠，丢包后数据丢失 | 无序              | 有边界，无粘包     | 无       | 快       | 高   | 8字节     |


UDP socket ⽀持 n 对 m 的连接状态。在 Node.js 官⽅⽂档中有写到在 `dgram.createSocket(options[, callback])` 中的 `options` 中可指定 `reuseAddr` 为 `SO_REUSEADDR` 标志，通过它可以简单的实现 n 对 m 的多播特性 (仅在⽀持多播的操作系统上才有用)。

## 什么是 TCP 粘包，怎么处理？

TCP 连接在默认情况下会启⽤延迟传送算法 (Nagle算法)，它在数据发送前进行缓存数据，如短时间内有多个数据发送，会缓冲后再作⼀次发送操作 (缓冲区⼤⼩可⻅ `socket.bufferSize`)，这样可以减少 IO 产生的消耗，提⾼了性能。

在传输⽂件的情况下，不⽤处理粘包问题，接收到⼀个包就拼接⼀个包就行了。但是，如果是传输多条消息、或是别的⽤途的数据，那么就需要处理粘包。可参⻅⽹上流传甚⼴的⼀个例⼦：连续调⽤两次 `send` 分别发送两段数据 data1 和 data2，则在接收端会有以下⼏种常⻅情况出现:

- A. 先收到 data1，然后收到 data2

- B. 先收到 data1 的部分数据，然后收到 data1 余下的部分以及 data2 的全部

- C. 先收到 data1 的全部数据和 data2 的部分数据，然后收到 data2 的余下的数据

- D. ⼀次性收到 data1 和 data2 的全部数据


以上情况中的 `B、C、D` 三种，就是常⻅的粘包情况。而处理粘包问题的常⻅⽅案有：

**方案一：多次发送之前间隔⼀个等待时间**

只需等待⼀段时间再做下⼀次`send` 发送操作就可以了。

- 它适⽤于交互频率特别低的场景

- 对于交互频繁的场景来说， 其传输效率太低。


**方案二：关闭 Nagle 算法**

在 Node.js 中你可以通过 `socket.setNoDelay()` ⽅法来关闭 Nagle 算法，让每次 send 都不缓冲而直接发送。

- 该⽅法适⽤于每次发送的数据都⽐较⼤ (但不是如⽂件那么⼤)， 并且频率不特别⾼的场景

- 如果是每次发送的数据量⽐较⼩且频率特别⾼的话，这种方式纯属⾃废武功

- 该⽅法也不适⽤于⽹络较差的情况，因为 Nagle 算法是在服务端进⾏的包合并情况，但如果短时间内客户端的⽹络


情况不好、或者应⽤层由于某些原因不能及时将 TCP 的数据 `recv`，就会造成多个包在客户端缓冲从⽽粘包的情况

**方案三：进⾏封包/拆包**

这是⽬前业内最常⻅的解决⽅案，即在发送每个数据包之前，将⼀些有特征的数据放在数据包前/后，然后在收到数据的时

候，根据特征数据来分割出各个数据包。

## 你知道哪些常用的端口号，以及它们对应的服务？

| 端口     | 用途                                                         |
| -------- | ------------------------------------------------------------ |
| 21       | 主要⽤于FTP（File Transfer Protocol，⽂件传输协议）服务      |
| 23       | 主要⽤于Telnet（远程登录）服务，是Internet上普遍采⽤的登录和仿真程序 |
| 25       | 为 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）服务器所开放，主要⽤于发送邮件，如今绝⼤多数邮件服务器都使⽤该协议 |
| 53       | 为DNS（Domain Name Server，域名服务器）服务器所开放，主要⽤于域名解析，DNS服务在NT系统中使⽤的最为⼴泛 |
| 67、68   | 分别是为 Bootp 服务的 Bootstrap Protocol Server（引导程序协议服务端）和 Bootstrap Protocol Client（引导程序协议客户端）开放的端⼝ |
| 69       | TFTP是Cisco公司开发的⼀个简单⽂件传输协议，类似于FTP         |
| 79       | 为Finger服务开放的，主要⽤于查询远程主机在线⽤户、操作系统类型以及是否缓冲区溢出等⽤户的详细信息 |
| 80       | 为HTTP（HyperText Transport Protocol，超⽂本传输协议）开放的，这是上⽹冲浪使⽤最多的协议，主要⽤于在WWW（World WideWeb，万维⽹）服务上传输信息的协议 |
| 99       | ⽤于⼀个名为“Metagram Relay”（亚对策延时）的服务，该服务⽐较少⻅，⼀般是⽤不到的 |
| 109、110 | 为POP2（Post Office Protocol Version 2，邮局协议2）服务开放的，110 端⼝是为 POP3（邮件协议3）服务开放的，POP2、POP3都是主要⽤于接收邮件的 |
| 111      | 是SUN公司的 RPC（Remote ProcedureCall，远程过程调⽤）服务所开放的端⼝，主要⽤于分布式系统中不同计算机的内部进程通信，RPC在多种⽹络服务中都是很重要的组件 |
| 113      | 主要⽤于Windows的“Authentication Service”（验证服务）        |
| 119      | 是为“Network News TransferProtocol”（⽹络新闻组传输协议，简称NNTP）开放的 |
| 135      | 主要⽤于使⽤RPC（Remote Procedure Call，远程过程调⽤）协议并提供DCOM（分布式组件对象模型）服务 |
| 137      | 主要⽤于“NetBIOS Name Service”（NetBIOS名称服务）            |
| 139      | 是为“NetBIOS Session Service”提供的，主要⽤于提供Windows⽂件和打印机共享以及Unix中的Samba服务 |
| 143      | 主要是⽤于“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP） |
| 161      | 是⽤于“Simple Network Management Protocol”（简单⽹络管理协议，简称SNMP） |
| 443      | ⽹⻚浏览端⼝，主要是⽤于HTTPS服务，是提供加密和通过安全端⼝传输的另⼀种HTTP |
| 554      | 默认情况下⽤于“Real Time Streaming Protocol”（实时流协议，简称RTSP） |
| 1024     | ⼀般不固定分配给某个服务，在英⽂中的解释是“Reserved”（保留） |
| 1080     | 是Socks代理服务使⽤的端⼝，⼤家平时上⽹使⽤的WWW服务使⽤的是HTTP协议的代理服务 |
| 1755     | 默认情况下⽤于“Microsoft Media Server”（微软媒体服务器，简称MMS） |
| 4000     | 是⽤于⼤家经常使⽤的QQ聊天⼯具的，再细说就是为QQ客户端开放的端⼝，QQ服务端使⽤的端⼝是8000 |
| 5554     | ⼀种针对微软lsass服务的新蠕⾍病毒——震荡波（Worm.Sasser）利⽤TCP 5554端⼝开启⼀个FTP服务，主要被⽤于病毒的传播 |
| 5632     | 5632端⼝是被⼤家所熟悉的远程控制软件pcAnywhere所开启的端⼝   |
| 8080     | 8080端⼝同80端⼝，是被⽤于WWW代理服务的，可以实现⽹⻚        |


## 一次完整的HTTP服务过程是什么

当我们在web浏览器的地址栏中输入：`www.baidu.com`，具体发生了什么？

1. 对`www.baidu.com`这个网址进行DNS域名解析，得到对应的IP地址
2. 根据这个IP，找到对应的服务器，发起TCP的三次握手 ([tcp 三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809) )
3. 建立TCP连接后发起HTTP请求
4. 服务器响应HTTP请求，浏览器得到html代码
5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）
6. 浏览器对页面进行渲染呈现给用户
7. 服务器关闭关闭TCP连接

注：

1.DNS怎么找到域名的？

> DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存->缓存找不到就去找根域名服务器->根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器


2.为什么HTTP协议要基于TCP来实现？

> TCP是一个端到端的可靠面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）


3.最后一步浏览器是如何对页面进行渲染的？

> a）解析html文件构成 DOM树

b）解析CSS文件构成渲染树

c）边解析，边渲染

d）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载


## 什么是DNS 解析

**DNS解析（域名解析服务器）**

假定请求的是 www.baidu.com

a）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）

b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存

c）如果还没有找到，那么尝试从 hosts 文件里面去找

d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找(就近查找)，具体过程如下

![](http://weldon.flywen.top/image/20210527235407.png#alt=dns域名解析)

DNS优化两个方面：DNS缓存、DNS负载均衡 (准备多台dns服务器, 进行dns解析)

## 什么是三次握手？

三次握⼿（Three-way Handshake）是指在建⽴⼀个 TCP 连接时，需要客户端和服务器总共发送 3 个包。

三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信

息。在 socket 编程中，客户端调用执行 `connect()` 时将触发三次握⼿。

下图为三次握手的示意图：

![](https://wuxiaohui-1254415986.cos.ap-nanjing.myqcloud.com/uPic/20210527235322.png)

**第⼀次握⼿（SYN=1, seq=x）**

客户端发送⼀个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X，保存在包头的序列号（Sequence Number）字段⾥。

发送完毕后，客户端进⼊ SYN_SEND 状态。

**第⼆次握⼿（SYN=1, ACK=1, seq=y, ACKnum=x+1）**

服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域⾥，同时将确认序号（Acknowledgement Number）设置为客户的 ISN 加1，即 X + 1。

发送完毕后，服务器端进⼊ SYN_RCVD 状态。

**第三次握⼿（ACK=1，ACKnum=y+1）**

客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对⽅，并且在数据段放写 ISN 的 +1。

发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿结束。

## 什么是四次挥手？

四次挥⼿（Four-way handshake），也叫做改进的三次握⼿，TCP 连接的拆除需要发送四个包，客户端或服务器均可主动发起挥⼿动作，在 socket 编程中，任何⼀⽅执⾏ `close()` 操作即可产⽣挥⼿操作。

下图为四次挥手示意图：

![](https://wuxiaohui-1254415986.cos.ap-nanjing.myqcloud.com/uPic/20210527235328.png)

**第⼀次挥⼿（FIN=1，seq=x）**

假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为1的包，表示⾃⼰已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进⼊ FIN_WAIT_1 状态。

**第⼆次挥⼿（ACK=1，ACKnum=x+1）**

服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务器端关闭连接。

**第三次挥⼿（FIN=1，seq=y）**

服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个ACK。

**第四次挥⼿（ACK=1，ACKnum=y+1）**

客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。

## TCP 三次握手理解 (双方确认)

TCP是一个端到端的  **可靠**  面相连接的协议，

HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）

根据这个IP，找到对应的服务器，发起TCP的三次握手 ([tcp 三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809) )

![](https://wuxiaohui-1254415986.cos.ap-nanjing.myqcloud.com/uPic/20210527235335.png)

**为什么要3次握手**

我们假定第一次发送的请求,  因为网络延迟很慢才到达服务端，

然后客户端以为这服务器居然不叼我，然后默默的关闭的等待连接的请求，走开了（好比追女神）；

但事实呢？女神（服务器）是因为各种各样的原因，很晚才看到，然后说我接受你了, 同意你的要求咱们两结婚吧！

但是，A早已经远走高飞，这个请求A完全不会收到（在第二次握手，服务端打开连接，等待客户端的响应），

那么女生呢，以为对方收到了，就会一直等待，这样B的资源就会被浪费的（创建连接的时候，空间浪费以及端口消耗）；

而三次握手, 就不会发生，服务端同意连接了，但是A缺一直没有下一步的动作，导致资源浪费；

## 关闭TCP连接四次挥手的理解 (客气挽留)

关闭连接(四次挥手)

![](https://wuxiaohui-1254415986.cos.ap-nanjing.myqcloud.com/uPic/20210527234202.png)

这和有礼貌的好友道别一样：（a：客户端 b:服务端）

1、一开始A想要回家离开，但是呢？怕B还有事情要交代，那么呢？只好先想B打招呼，我要走了，请求停止交谈（此时，a到B的连接没有断开，依旧可以进行通信）；

2、同意A的请求，说好的，但是我这里可能还有一些话（数据）没说完。我检查看看,  你等等,  等我说完你再走。

3、B确实没啥要补充的了，就告知你我可以散伙了

4、A说好的，知道了，88；（B得知A走开了，关闭了自己的连接 )

## 浏览器解析响应

**浏览器解析html代码，并请求html代码中的资源**

**浏览器对页面进行渲染呈现给用户**

最后，浏览器利用自己内部的工作机制，把请求的静态资源和html代码进行渲染，渲染之后呈现给用户，浏览器是一个边解析边渲染的过程。

首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。

DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repaint。

**页面在首次加载时必然会经历reflow和repaint。**

reflow过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。

所以我们应该尽可能少的减少 reflow (重新布局) 。  例如: transform 变换, 只会触发重绘, 不会触发重排 (效率非常高)

...

页面首次渲染, 必然会进行一次 reflow 和 一次 repaint

1. reflow: 重排 (布局相关的)
2. repaint: 重绘(绘制, 颜色, 字体, .... 跟结构无关的)

**完整的一次 http 请求流程才算结束**